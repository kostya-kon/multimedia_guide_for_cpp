{% extends "index.html" %}
{% load static %}

{% block main %}
<p class="theme text">Тема 4.  Масиви, рядки мови С++ </p>
            <p class="lesson text"> Урок 2. Багатовимірні масиви </p>
            <p class="subTheme text" id="subTheme4_2_1">Багатовимірні масиви С++ </p>
             <p class="regular text">
                Якщо елемент масиву має не один, а декілька індексів, то такі масиви називаються багатовимірними. Прикладами багатовимірних
                масивів можуть бути різноманітні табличні дані: річний табель учня, сторінка в шкільному журналі, таблиця результатів футбольних
                змагань тощо. Це двовимірні таблиці, яким у математиці відповідає поняття матриці.<br>
                Загальний вигляд конструкції опису багатовимірного (N-вимірного) масиву такий:<br>
             </p>
             <p class="code"> <тип> <ім'я масиву>[<р1>][<р2>] ... [<Pn>] ,</p>
             <p class="regular">
                Де р1, р2, ... , PN задають розміри для кожного виміру.<br>
                Кількість індексів визначає вимірність масиву: двовимірні масиви мають два індекси, тривимірні - три і т.д.<br>
                Усі багатовимірні масиви можна розглядати й опрацьовувати як одновимірні. Наприклад, тривимірний масив sal[5][20][30] можна
                інтерпретувати як п'ять масивів розміром 20Х30, а інші- як  20 одновимірних масивів, які містять по 30 елементів.<br>
                Надалі, для простоти викладу, розглядатимемо двовимірні масиви.<br>
                Елементи двовимірного масиву визначаються іменем масиву та двома індексами: перший індекс означає номер рядка, інший- номер стовпця,
                на перетині яких розміщений елемент.<br>
                Наприклад, оголосимо масив int doba[24][60]. Він містить елементи цілого типу і складається з 24 рядків і 60 стовпців. Елемент doba[23][59]
                розміщений на перетині останнього 24-го рядка та останнього 60-го стовпця (нумерація індексів масиву завжди починається з нуля).<br>
                Двовимірні масиви компілятор розглядає як послідовність одновимірних. Тому до елементів двовимірного масиву, як і для одновимірних, можна
                також звертатись через вказівники.<br>
                У такому випадку це вказівник на вказівник одномірного масиву:<br>
             </p>
             <p class="code">*(*(<назва вказівника>+<зміщення по рядках>) + <зміщення по стовпцях>)</p>
             <p class="regular">
                Наприклад, елемент *(*(doba+2)+15) розміщений на перетині 3-го рядка та 16-го стовпця.<br>
                Під час оголошення двовимірні масиви можна частково або повністю ініціалізувати.<br>
                <br>Приклад 2. Оголосимо і проініціалізуємо двовимірний масив цілих чисел <br>
             </p>
             <p class="code">
                int bаll[2][З] = {4, 5, З, З, 5, 2}.<br>
                У такому випадку елементам надаються значення так:<br>
                bаІІ[0][0] = 4, bаІІ[0][1] = 5, bаІІ[0][2] = З,<br>
                bаІІ[1][0] =З, bаІІ[1][1] = 5, bаІІ[1][2] = 2.<br>
            </p>
             <p class="regular">
                Двовимірні масиви автоматично ініціалізуються "по рядках", тобто спочатку модифікується зовнішній (правіший) індекс.<br>
                Надавати значення елементам масиву можна і так:<br>
            </p>
             <p class="code">
                int bаІІ[2][З] = { {4, 5, З}, {З, 5, 2} };<br>
                або так:<br>
                int bаІІ[2][З] = {<br>
                4, 5, З,<br>
                З, 5,2<br>
                };<br>
             </p>
             <p class="subTheme" id="subTheme4_2_2"> Задачі (масиви)  </p>
             <p class="regular text">
                <br>Задача 1 (про таблицю множення). Скласти програму для занесення в двовимірний масив р таблиці множення двох чисел і виведення
                масиву на екран.<br>
                // Програма Піфагор<br>
             </p>
             <p class="code">
                    #include &lt iostream.h &gt<br>
                    #include &lt conio.h &gt<br>
                    void main()<br>
                    {<br>
                    clrscr();<br>
                    const n = 9;<br>
                    int p[n][n];<br>
                    for (int і= 0; і &lt n; і++)<br>
                    {<br>
                    for (int j =0; j &lt n; j++)<br>
                    { //Множення чисел<br>
                    р[і][j] = (і + 1) * (j + 1 );<br>
                    cout « р[і][j] « "\t";<br>
                    } <br>
                    cout &lt&lt "\n"; // Для виводу масиву у вигляді таблиці<br>
                    }<br>
                    getch();<br>
                    }<br>
                 </p>
                 <p class="regular">
                   <br> Задача 2 (про кондитерську фабрику). Кондитерська фабрика для виготовлення п'яти сортів цукерок використовує п'ять видів
                    сировини. Нехай норми затрат а;і кожного виду сировини і на виробництво 1 т цукерок сорту j задані формулою
                    аij = lsinil + j (і, j = 1, 2, ... , 5). Вивести на екран таблицю затрат сировини (тобто масив а). Визначити, для якого
                    сорту цукерок (imin) потрібно найменше сировини (min) третього виду.
                 </p>
                 <p class="code">
                    #include &lt iostream.h &gt<br>
                    #include &lt conio.h &gt<br>
                    #include &lt math.h &gt<br>
                    void Min(float v[5][5]);<br>
                    void main()<br>
                    {<br>
                    clrscr();<br>
                    float Vytraty[5][5];<br>
                    cout &lt&lt "\t\t\t Вид сировини\n";<br>
                    cout  &lt&lt "\t 1\t 2\t З\t 4\t 5\n";<br>
                    // Утворимо таблицю затрат<br>
                    for (int і= 0; і &lt 5; і++)<br>
                    {<br>
                    cout &lt&lt і + 1 &lt&lt " сорт";<br>
                    for (int j =0; j &lt 5; j++)<br>
                    {<br>
                    *(*(Vytraty + і) + j) = 2 * fabs(sin(i + 1 )) + j + 1;<br>
                    // Вивід елементів і-го рядка<br>
                    cout &lt&lt *(*(Vytraty + і) + j) &lt&lt "\t";<br>
                    }<br>
                    cout &lt&lt "\n"; // Перехід на новий рядок<br>
                    }<br>
                    Min(Vytraty); // Виклик процедури Міn<br>
                    getch();<br>
                    }<br>
                    //---------------------------------------------------------<br>
                    void Min(float v[5][5])<br>
                    { <br>
                    /* Припустимо, що найменше сировини третього<br>
                    виду потрібно для цукерок першого сорту */<br>
                    int imin = 1;<br>
                    float min =*(*v);<br>
                    for (int і= 1; і &lt 5; і++)<br>
                    {<br>
                    // Переглядаємо елементи З-го рядка<br>
                    if (*(*(v + і) +З) &lt min)<br>
                    {<br>
                    min = *(*(v +і) + З);<br>
                    imin =і;<br>
                    }<br>
                    cout &lt&lt "\n Найменше сировини третього виду \n";<br>
                    cout &lt&lt "nотрібно для цукерок " &lt&lt imin &lt&lt "сорту";<br>
                    }<br>
                 </p>
                 <p class="regular text">
                    Увага! Нехай задана деяка матриця aij,i, j = 1, 2, ... , n. Тоді вирази і = j, і &lt j та і &gt j визначають відповідно
                    елементи головної діагоналі, елементи над і під головною діагоналлю цієї матриці.
                 </p>
            <p class="subTheme" id="subTheme4_2_3"> Упорядкування масивів  </p>
             <p class="regular">
                Задачі впорядкування даних у масиві мають важливе практичне значення. Прикладами таких даних можуть біти телефонні довідники
                (дані, упорядковані  за прізвищем адресатів), бібліотечні каталоги, розклади руху потягів тощо. Упорядковані дані значно легше
                опрацьовувати, оскільки серед них набагато швидше можна відшукати потрібну інформацію.<br>
                Дані у масиві можна впорядковувати за зростанням (від меншого до більшого) або за спаданням (від більшого до меншого).<br>
                <br>Задача 3 (про упорядкування масиву). Розглянемо масив А, який містить цілі числа 5, 2, 3, 6, 1, 4. Упорядкувати цей масив за
                зростанням значень.<br>
                <br>Є багато різних способів упорядкування даних в одновимірному масиві. Розглянемо декілька з них.<br>
                Метод обміну ("бульки"). Читаємо два перші елементи масиву (5 та 2) і порівнюємо їх між собою. Якщо перший елемент більший за
                другий, то міняємо їх місцями (стане 2 і 5). Далі розглядаємо другий і третій елемент (тепер це елементи 5 і 3) і порівнюємо їх
                між собою. Якщо треба, то міняємо їх місцями (стане 3 і 5). Потім порівнюємо третій і четвертий елементи (5 і 6) і так далі.
                Отримаємо масив 2, 3, 5, 1, 4, 6. Таким чином максимальний елемент (це елемент 6) опинився в самому кінці масиву, тобто там, де
                потрібно. Після цього знову розглядаємо масив, але вже без останнього елемента. Застосовуємо метод обміну до нового масиву
                (2, 3, 5, 1, 4). На останньому місці опиниться 5. Далі знов розглядатимемо масив без останнього елемента і застосовуватимемо метод
                обміну і т. д. Якщо масив має n елементів, то метод обміну треба застосувати n - 1, разів до кожного разу меншої кількості елементів.
                Упорядковані елементи будуть нагромаджуватись із кінця масиву.<br>
                Складемо програму<br>
                // Впорядкування масиву методом обміну елементів<br>
             </p>
             <p class="code">
                #include &lt iostream.h &gt<br>
                #include &lt conio.h &gt<br>
                void sort(int m[6]);<br>
                void main()<br>
                {<br>
                clrscr();<br>
                int і;<br>
                int а[6];<br>
                cout &lt&lt "Введіть 6 чисел: \n";<br>
                for (і =0 і &lt 6; і++) ·<br>
                cln >> *(а+ і); <br>
                sort(a);<br>
                cout &lt&lt "Упорядкований масив: \n"<br>;
                for (і = 0; і &lt 6; і++)<br>
                cout &lt&lt *(а+ і) &lt&lt "\n";<br>
                getch();<br>
                } <br>
                //------------------------------------------------------------<br>
                void sort(int m[6])<br>
                {<br>
                int temp, і, j;<br>
                for (і= 0; і &lt 5; і++)<br>
                for (j =0; j &lt 6- і- 1; j++)<br>
                if (*(m + j) > *(m + j + 1))<br>
                {<br>
                temp = *(m + j + 1 );<br>
                *(m + j + 1) = *(m + j);<br>
                *(m + j) = temp;<br>
                }<br>
                }<br>
             </p>
             <p class="regular text">
                Увага! Оскільки назва масиву - це вказівник на пер ший елемент цього масиву, а функції користувача можуть повертати значення у
                програму не тільки за допомогою команди return, а й через вказівники, то у програмі сортування масиву міняємо місцями значення
                елементів масиву а за допомогою функції sort(), використовуючи вказівники.<br>
                Розглянемо інші методи упорядкування масивів.
                Метод міпімальних елементів. Розглядають увесь масив і визначають номер мінімального елемента. Тоді перший елемент міняють місцями
                з мінімальним. Далі розглядають новий масив, уже без першого елемента. У ньому знов відшукують найменший та роблять заміну і т. д.
                Упорядковані елементи поступово переноситимуться на початок масиву. Цей метод- один з найпростіших, але найтриваліший. <br>
                Метод вставки. Поступово порівнюємо перший елемент зі всіма іншими, доки не знайдемо елемент менший від нього. Перша позиція в масиві
                - позиція вставки. Знайдений менший елемент і його індекси запам'ятовують. Усі елементи масиву, починаючи від позиції вставки до
                елемента, що передує знайденому, зміщують праворуч. Значення знайденого елемента записують у позицію вставки і порівнюють його з елементами,
                що залишилися. Якщо буде виявлено ще менший елемент, то повторюють процедуру вставки, і так доти, доки не дійдуть до кінця масиву - лише
                після цього перший елемент буде на місці. Розглядають масив без першого елемента і застосовують до нього описаний метод.<br>
                Увага! У модулі stdlib.h описана стандартна функція qsort(), яка дає змогує упорядковувати елементи масиву. <br>
                Її сигнатура така: <br>
             </p>
             <p class="code">qsort (*<елемент> , <кількість елементів>, <розмір одного елементу>, <функція порівняння>);</p>
             <p class="regular">
                де *<елемент> - вказівник на перший елемент масиву, функція порівняння - стандартна функція порівняння або функція, створена користувачем.
             </p>
{% endblock main %}

{% block anchors %}
<div class="anchors">
 <a href="#subTheme4_2_1">Багатовимірні масиви С++</a>
            <a href="#subTheme4_2_2">Задачі (масиви)</a>
            <a href="#subTheme4_2_3">Упорядкування масивів</a>
</div>
{% endblock anchors %}