{% extends "index.html" %}
{% load static %}

{% block main %}
<p class="theme text">Тема 4.  Масиви, рядки мови С++ </p>
            <p class="lesson text"> Урок 5. Стеки та черги</p>
            <p class="subTheme text" id="subTheme4_5_1">Стек </p>
             <p class="regular text">
              Стек - це структура даних, у якій елемент, записаний останнім, зчитують (він доступний для опрацювання) першим. Принцип "останній
              прийшов- перший пішов" використовується в багатьох технічних пристроях і в побуті: ріжок від автомата; посадка пасажирів у вагон,
              який має лише одні двері тощо. Стек використовують у програмуванні, зокрема, для реалізації рекурсії. Рекурсія виконується так:
              спочатку всі виклики нагромаджуються (аналогія така: пружина стискається), а потім виконуються вкладені функції (пружина
              розпрямляється).<br>
              Стек описують і створюють у пам'яті за допомогою типу даних структура. Над елементами стека визначені лише дві операції: занесення
              елемента у стек та вилучення елемента зі стека. У стеку завжди доступний є лише верхній елемент, який називають вершиною стека.
              Розглянемо типову задачу роботи зі стеком.<br>
              <br>Задача 1 (про символи).<br>
              Увести послідовність символів, де крапка (". ") є ознакою закінчення введення. Вивести введені символи на екран у зворотному порядку.
              Розв'яжемо цю задачу із застосуванням стека (stack), який містить такі поля: символ (ch), вказівник на наступний елемент стека (dali).
             </p>
             <p class="code">
              #include &lt iostream.h &gt<br>
              #include &lt conio.h &gt<br>
              struct stack //  Оголошення типу stack<br>
              (<br>
              char ch;<br>
              stack *dali;<br>
              };<br>
              stack *st,*element;<br>
              void StvorytyStek(stack *st);<br>
              void VyluchenniaZiSteku(stack *st);<br>
              void main()<br>
              (<br>
              st = NULL;<br>
              StvorytyStek( st);<br>
              VyluchenniaZiSteku(st);<br>
              } <br>
              //-------------------------------------------------------------------- <br>
              void StvorytyStek(stack *st)<br>
              (<br>
              char a;<br>
              do // Уводимо дані у стек<br>
              {<br>
              // Зчитуємо символ, уведений з клавіатури<br>
              а= getch();<br>
              element = new (stack); // Виділяємо місце для нового елемента<br>
              element -> dali = st; // Перенаправляємо вкaзівники<br>
              st = element;<br>
              element -> ch = a;<br>
              }<br>
              while (а!='.'); // Поки не введена крапка<br>
              }<br>
              //-------------------------------------------------------- <br>
              void VyluchenniaZiSteku(stack *st)<br>
              (<br>
               //Вилучення елементів зі стека та<br>
              do //виведення їх на екран<br>
              (<br>
              st = element -> dali; element = st;<br>
              cout &lt&lt st -> ch;<br>
              }<br>
              while (st -> dali != NULL);<br>
              }<br>
             </p>
            <p class="subTheme" id="subTheme4_5_2"> Черга </p>
             <p class="regular text">
              Черга - це структура даних, у яких елемент, записаний першим зчитують першим. Тут діє принцип "перший прийшов - перший пішов",
              добре відомий з побуту: черга у магазині тощо. Чергу, як і стек, описують з використанням структури . Над елементами черги
              визначені операції: занесення елемента у чергу та забирати з черги. У черзі доступним є лише нижній елемент.<br>
              <br>Приклад 1. Оголосимо нову структуру tsherga та два вказівники на цей тип
              </p>
             <p class="code">
              sturuct tsherga<br>
              (<br>
              char ch;<br>
              stack *dali;<br>
              };<br>
              tsherga *tsh,*element;<br>
             </p>

             <p class="regular text"> У цьому випадку, наприклад, створити відповідну чергу tsh можна за допомогою функції:</p>
             <p class="code">
              tsherga *StvorytyTshergu(void)<br>
              {<br>
              char  a;<br>
              element = new (tsherga);<br>
              // Запам ятовуємо адресу першого елемента черги<br>
              pershij = element;<br>
              cin >>а;<br>
              while(a!= '.') // Поки не введена крапка<br>
              {<br>
              element->ch =а; // Заповнюємо елементи черги<br>
              element -> dali = new (tsherga);<br>
              element = element -> dali;<br>
              cin >>а; // Вводимо наступну літеру<br>
              }<br>
              element = NULL;<br>
              return pershij;<br>
              }<br>
              Забирати елемент із черги можна за допомогою функції<br>
              void VyluchenniaZTshergu(tsherga *tsh)<br>
              {<br>
              while (tsh != NULL)<br>
              {<br>
              element = tsh;<br>
              cout &lt&lt element -> ch;<br>
              tsh = element -> dali;<br>
              }<br>
              }<br>
              </p>
              <p class="regular text">
                Максимально допустимі розміри стека і черги – важливі характеристики реалізації мови програмування. Вони визначають коло задач ,
                які можна розв`язати .
              </p>
            <p class="subTheme" id="subTheme4_5_3"> Об'єднання (union)   </p>
             <p class="regular">
              Опис об'єднань у мові С++ нагадує опис структур , але їхнє призначення інше. Об'єднання слугують для зберігання (послідовного,
              не одночасного) в деякій ділянці оперативної пам'яті комп'ютера даних різних типів . Потреба в цьому виникає, наприклад, під час
              створення таблиці з даними різних типів. Об'єднання можна описати так:
             </p>
             <p class="code">
              union &lt назва типу об'єднання><br>
              {<br>
              <тип поля 1 > <назва поля 1 >;<br>
              …<br>
              <тип поля n> <назва поля n>;<br>
              };<br>
             </p>
             <p class="regular">
              Усі правила, які розглядалися для опису та використання структур, діють і для об'єднань.<br>
              <br>Задача 2. (про конференцію). Для участі у конференції потрібно заповнити заявку: прізвище, ім'я, адресу, а також зазначати,
              чи треба бронювати номер у готелі. Якщо житло непотрібне, то записати свій контактний телефон, інакше - зазначити назву готелю.
              Створити програму, яка б давала змогу ввести отримані дані у базу даних конференції.
             </p>
             <p class="code">
              #include &lt iostream.h &gt<br>
                #include &lt conio.h &gt<br>
                union gotel_tel<br>
                {<br>
                char gotel[20];<br>
                char tel[7];<br>
                };<br>
                struct konfer<br>
                {<br>
                char name[15], surname[15], adres[15];<br>
                int br; // 1- треба бронювати номер, 2- ні<br>
                gotel_tel bron;<br>
                };<br>
                void main()<br>
                {<br>
                Int n=1;<br>
                konfer z;<br>
                while (n == 1)<br>
                {<br>
                cout &lt&lt "\n Уведіть прізвище, ім'я та адресу\п";<br>
                cin >> z.name >> z.surname >> z.adres;<br>
                cout &lt&lt "\n Треба житло? 1 -так, 0 - ні ";<br>
                cin >> z.br;<br>
                 if (z.br)<br>
                {<br>
                cout &lt&lt "\n Уведіть назву готелю\n";<br>
                cin >> z.bron.gotel;<br>
                } <br>
                else<br>
                {<br>
                cout &lt&lt "\n Уведіть номер телефону\n" ;<br>
                cin >> z.bron.tel;<br>
                }<br>
                cout &lt&lt "\n Наступна заявка? 1 -так, О - ні ";<br>
                cin >> n;<br>
                }<br>
                }<br>
             </p>
{% endblock main %}

{% block anchors %}
<a href="#subTheme4_5_1">Стек</a>
            <a href="#subTheme4_5_2">Черга</a>
            <a href="#subTheme4_5_3">Об'єднання (union)</a>
{% endblock anchors %}