{% extends "index.html" %}
{% load static %}

{% block main %}
<p class="theme text">Тема 4.  Масиви, рядки мови С++ </p>
            <p class="lesson text"> Урок 4. Структури та списки </p>
            <p class="subTheme text">Структури. </p>
             <p class="regular text">
               Структура - це спеціальний тип даних, який створює користувач для опрацювання інформації про об'єкти з деякої предметної області.
               Така інформація може складатися з даних різних типів. <br>
               Структура складається з набору полів - даних різних типів, і її тип  описується так: <br>
             </p>
             <p class="code">
               struct <назва типу структури><br>
               {<br>
               <тип поля 1 > <назва поля 1 >;<br>
               …<br>
               <тип поля n> <назва поля n>;<br>
               };<br>
             </p>
             <p class="regular">
               Опис структури обов'язково закінчується символом ";" .<br>
               <br> Приклад 1. Структуру, яка містить анкетні дані студентів (прізвище, ім'я та середній бал), можна описати так:</p>
             </p>
             <p class="code">
               struct grupa<br>
               {<br>
               char name[20], surname[20];<br>
               float serball;<br>
               };<br>
             </p>
             <p class="regular">
               Увага! Під час оголошення структури можна задавати обсяг пам'яті, який займатимуть змінні певного поля. Для цього після назви
               поля ставиться знак двокрапки та зазначається ціле число або стала - кількість байтів. Такі поля називають бітовими. <br>
               Визначити обсяг, який займає ціла структура, можна так: sіzеоf(<назва типу структури>).<br>
               Коли у програмі описана структура, то оголосити змінні або вказівники цього типу можна так:<br>
               <назва типу структури> <список змінних і вказівників>;<br>
               Наприклад, оголосимо змінні gr1 і gr2, вказівник р для структури з прикладу 1 <br>
             </p>
             <p class="code">
               grupa gr1, gr2;<br>
               grupa *р;<br>
             </p>
             <p class="regular">Оголосити змінні типу структура можна ще й так:</p>
             <p class="code">
               struct <назва типу структури><br>
               {<br>
               <тип поля 1 > <назва поля 1>;<br>
                ...<br>
               <тип поля n> <назва поля n> ;<br>
               } <список змінних і вказівників>;<br>
             </p>

             <p class="regular">
               Якщо тип структури визначати не обов' язково, а достатньо лише оголосити її змінні, то назву типу структури можна не зазначати.
             </p>
            <p class="subTheme"> Приклади структур  </p>
             <p class="regular text"> <br>Приклад 2. Структуру та змінні з прикладу 1 оголосимо так:</p>
             <p class="code">
               struct grupa<br>
               {<br>
               char name[20], surname[20];<br>
               float serball;} gr1, gr2, *р; <br>
               }<br>
             </p>
             <p class="regular text">  Оголосити лише змінні можна так:</p>
             <p class="code">
               struct<br>
               {<br>
               char name[20], surname[20];<br>
               float serball;<br>
               } gr1, gr2, *р; <br>
             </p>
             <p class="regular text">Структура може містити поля типу структура.<br>
               <br>Приклад 3. Оголосимо структуру grupa1 та дві змінні grA, grB цього типу. Нехай структура grupa1 містить поля прізвище, ім' я,
               середній бал і структуру дату народження (birthday), яка складається з полів: рік, місяць, число.
             </p>
             <p class="code">
               struct grupa 1<br>
               {<br>
               char name[20], surname[20];<br>
               struct<br>
               {<br>
               int year, month, day;<br>
               } birthday;<br>
               float serball;<br>
               } grA, grB;<br>
             </p>
             <p class="regular text">
               Змінні типу структура можна ініціалізувати відразу під час оголошення.<br>
              <br>Приклад 4. Оголосимо та проініціалізуємо змінну gr
             </p>
             <p class="code">
               struct grupa<br>
               {<br>
               char name[20], surname[20];<br>
               float serball;<br>
               } gr = {"Ярмолюк", "Олександра", 4.9};<br>
             </p>
             <p class="regular">
               Тут поле name змінної gr має значення Ярмолюк, поле surname -значення Олександра, а поле serball- 4,9.<br>
               Доступ до конкретного поля зміппої типу структура дає складене ім'я вигляду<br>
               <назва змінної>.<назва nоля><br>
               <br>Приклад 5. Змінним grA та grB з прикладу 3 можна надати значення
             </p>
             <p class="code">
               strcpy(grA.name, "Чайковський");<br>
               grB.birthday.day = 28;
             </p>
             <p class="regular">
               Можна також створювати вказівники на структури. Доступ до полів вказівника па структуру здійснюється дещо інакше, ніж до полів
               відповідної змінної, а саме:<br>
               <назва вказівника> -> <назва поля><br>
               <br>Приклад 6. Оголосимо вказівник р на структуру grupa1 з прикладу 3 та проініціалізуємо його.
             </p>
             <p class="code">
               grupa1 *р; // Вказівник р вказує<br>
               р = &amp grA; //на адресу змінної grA<br>
               // Заповнюємо значення полів serball<br>
               p->serball = 4.7;<br>
               p->birthday.year = 1986; //на birthday.year
             </p>
             <p class="regular">
               Масив змінних типу структура можна оголосити так:<br>
               <назва типу структура> <назва масиву>[кількість елементів];<br>
               Доступ до полів окремих елементів масиву здійснюється так:<br>
               <назва елемента>[індекс]. <назва поля><br>
               Змінні типу структура можуть бути аргументами функцій. Для них діють ті ж самі правила, що і для змінних стандартних типів.
             </p>
            <p class="subTheme"> Поняття про список   </p>
             <p class="regular">
               Розглянемо структуру даних - однонаправлений( однозв’язний) список. Список - це скінчений набір даних одного типу, між якими
               налагоджено зв'язок. Елемент однонаправленого списку складається з двох частин: самого даного (часто складеного) та вказівника
               на наступний елемент списку. Для опису списку використовують тип даних структура і вказівник, а саме:<br>
             </p>
             <p class="code">
               struct <назва типу списку><br>
               {<br>
               <тип поля 1 > <назва поля 1 >;<br>
               …;<br>
               <тип поля n> <назва поля n>;<br>
               <тип вказівника> *<назва типу списку>;<br>
               };<br>
               <назва типу списку> *<назва вказівника 1 >, ... ,<br>
               *<назва вказівника n>;<br>
             </p>
             <p class="regular">
               <br>Приклад 7. Створимо структуру про річку (rika), яка містить поля: назва, довжина річки у кілометрах та площа басейну у квадратних
               кілометрах, і поставимо їй у відповідність елементи списку:
             </p>
             <p class="code">
               struct rika // Створюємо тип rika<br>
               {<br>
               char nazva[12];<br>
               int dov;<br>
               long int рІ;<br>
               rika *dali; // Створюємо поле вквзівник на тип rika<br>
               };<br>
               rika *element, *pershij, *poperednij, *novyj;<br>
             </p>
             <p class="regular">
               Тут element- вказівник (тип структура rika) на поточний елемент списку, element -> dov- динамічна змінна цілого типу (int), яка
               містить значення довжини річки, а element -> dali – вказівник на наступний елемент списку. Звідси випливає, що
               element -> dali -> dov - це довжина наступної річки, а element -> dali ·> dali - вказівник на ще наступну річку і т.д.<br>
               <br>Задача 2 (про річки). Утворити список, який містить інформацію про річки. Вивести цей список на екран. Додати на початок списку
               новий запис. Вивести список зі змінами. Щоб увести дані про всі річки, можна використати тип даних - масив структур. Вважатимемо,
               що кількість річок, про які необхідно ввести інформацію, невідома, тому звичайний масив використати не можна. Навіть якщо кількість
               даних відома, то працювати з таким масивом не раціонально. Адже щоб вставити в середину масиву новий елемент, потрібно зміщувати
               "хвіст масиву" праворуч. Щоб уникнути цього, застосовують список. Програма Сnисок рік розв'язує поставлену задачу і демонструє
               основні прийоми опрацювання списку. Елементи списку опрацьовують один за одним за допомогою команд циклу. Спочатку створюють список
               і вводять із клавіатури в нього дані. Щоб завершити введення даних, домовимося ввести нулі для значень назви, довжини та площі
               басейну річки. Після завершення введення буде створено зайвий (останній) елемент списку (з нулями). Його слід пізніше ліквідувати,
               заздалегідь оголосивши ще один вказівник (на попередній елемент списку) і прийнявши poperednij -> dali = NULL. Суттєва перевага
               списків у тому, що вилучити зафіксований (тобто вибраний відповідно до деякої умови) елемент можна за допомогою одної команди
               переадресації вигляду poperednij -> dali = zafix -> dali. Виводимо список на екран. Створюємо новий елемент списку і вводимо в
               його поля дані. Новий елемент зробимо першим у списку. Суттєва перевага списку над масивом і в цьому разі: щоб вставити новий
               елемент після зафіксованого, потрібно лише дві команди переадресації і жодної "брудної роботи з хвостом". Вказівник нового
               елемента переадресовуємо туди, куди вказував вказівник зафіксовано елемента, а вказівник зафіксованого елемента "втикаємо" в новий
               елемент:<br>
             <p class="code">
               novyj->dali = zafix->dali;<br>
               zafix->dali = novyj;
             </p>
             <p class="regular">  // Список рік</p>
             <p class="code">
               #include &lt iostream.h &gt<br>
               #include &lt conio.h &gt <br>
               struct rika // Створюємо тип rika<br>
               {<br>
               char nazva[12];<br>
               int dov;<br>
               long int рІ;<br>
               rika *dali; // Створюємо поле вкгзівник типу rika<br>
               };<br>
               rika *element, *pershij, *poperednij, *novyj;<br>
               void StvorytySpysok(void); // Функція створення списку<br>
               void VyvestyNaEkran(void); // Функція виведення списку на екран<br>
               void StvorytyNjvyjEiement(void); // Функція створення нового елемента<br>
               void main()<br>
               {<br>
               cout &lt&lt  "Створення списку\n"<br>
               cout &lt&lt  "Для закінчення еведіть усі нулі\n";<br>
               StvorytySpysok();<br>
               VyvestyNaEkran();<br>
               . StvorytyNjvyjElement();<br>
               // Додаємо до початку списку новий елемент<br>
               element = pershij;<br>
               novyj -> dali = element;<br>
               pershij = novyj;<br>
               cout &lt&lt  "Новий список \n";<br>
               VyvestyNaEkran();<br>
               }<br>
               //---------------------··-------------------------------------·-···<br>
               void StvorytySpysok(void) <br>
               {<br>
               element = new (rika);<br>
               pershij = element;<br>
               do<br>
               (<br>
               poperednij = element;<br>
               cout &lt&lt  "Уведіть назву, довжину та площу річки\n";<br>
               cin >> eiement -> nazva;<br>
               cin >> eiement -> dov;<br>
               cin >> element -> рL;<br>
               element -> daLi = new (rika);<br>
               element = eLement -> dali;<br>
               }<br>
               while (poperednij -> dov !=0 || poperednij ->рі !=0);<br>
               poperednij -> dali = NULL;<br>
               }<br>
               // ·······-·······-·······-···-··-···-····-·-···-·-········<br>
               void VyvestyNaEkran(void)<br>
               (<br>
               cout &lt&lt  "Створено такий список:\n";<br>
               eiement = pershij;<br>
               while (element != NULL)<br>
               ( <br>
               cout &lt&lt  element -> nazva &lt&lt  "\t" &lt&lt br>
               element -> dov &lt&lt  "\t" &lt&lt  element -> рІ &lt&lt  "\n";<br>
               element = element -> dali;<br>
               }<br>
               }<br>
               //-----------------------------------------------------------<br>
               void StvorytyNjvyjEiement(void)<br>
               { <br>
               novyj = new (rika);<br>
               cout &lt&lt "Уведіть назву, довжину та nлощу нової річки\n";<br>
               cin >> novyj -> nazva >> novyj -> dov >> novyj -> рІ;<br>
               }<br>
             </p>
{% endblock main %}

{% block anchors %}
<a href="#subTheme4_4_1">Структури.</a>
          <a href="#subTheme4_4_2">Приклади структур</a>
          <a href="#subTheme4_4_3">Поняття про список</a>
{% endblock anchors %}