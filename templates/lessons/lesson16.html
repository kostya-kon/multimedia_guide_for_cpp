{% extends "index.html" %}
{% load static %}

{% block main %}
<p class="theme text">Тема 4. Масиви, рядки мови С++ </p>
<p class="lesson text">Урок 1. Масиви </p>
<p class="subTheme text" id="subTheme4_1_1">Масив це? </p>
<p class="regular text">
   Масив - це впорядкований скінченний набір даних одного типу, які зберігаються в послідовно розташованих комірках
   оперативної
   пам'яті і мають спільну назву.<br>
   Назву масиву надає користувач. Масив складається з елементів. Кожен елемент має індекси, за якими його можна знайти у
   масиві.
   Кількість індексів визначає розмірність масиву. Розрізняють одно - та багатовимірні масиви. <br>
   Наприклад, двовимірний масив даних -це таблиця, що складається з декількох рядків і стовпців. У математиці поняттю
   масив
   відповідають поняття вектора та матриці. Загальний вигляд конструкції опису одномірного масиву такий:<br>
</p>
<p class="code">
   <тип>
      <ім'я масиву>[<розмір>]
</p>
<p class="regular text">
   Розмір - це кількість елементів масиву. Розмір масиву необхідно знати і задавати заздалегідь, оскільки компілятор має
   зарезервувати для нього необхідний обсяг пам'яті. Розміром може бути лише стала величина (не змінна).<br>
   Ім' я масиву у програмі змінювати не можна - це стала величина, яка містить адресу першого елемента. Отже, назва
   масиву є
   вказівником на перший елемент.<br>
   Наприклад, команда int stud[5] оголошує масив з іменем stud, який складається із п'яти цілих чисел; команда float
   rist[10]
   оголошує масив rist, який містить десять чисел дійсного типу; char alphavit[6]- оголошення масиву із 6 символів.<br>
   Звернутись до елементів масиву можна двома способами: за допомогою імені масиву або використовуючи вказівники.<br>
   Увага! У навчальних цілях використання імен більш наочне, однак відповідно до професійного підходу слід надавати
   перевагу
   вказівникам.<br>
   Нумерація елементів масиву завжди починається з нуля. Щоб звернутись до деякого елемента, необхідно зазначити ім'я
   масиву, а у
   квадратних дужках - його номер. Наприклад, змінна stud[2] є третім елементом масиву stud, а stud[4] - п'яти, оскільки
   масив
   stud має елементи stud[0], stud[1], stud[2], stud[З] та stud[4].<br>
   Увага! Компілятор мови С++ не контролює належність індексу до заданого діапазону. Відповідальність за це несе
   програміст.
   Наприклад, якщо у програмі оголосити масив mas з ятьм а дійсними числами і написати команду mas[54] = 2, то
   повідомлення про
   помилку не буде, проте невідомо, у яку ділянку пам'яті потрапить число 2 і що трапиться.<br>
   Назва масиву stud є вказівником на його перший елемент. Змінна *stud містить значення першого елемента масиву (
   елемента stud[0]).
   Оскільки всі елементи масиву розміщені у послідовних комірках оперативної пам'яті комп'ютера, то вказівник (stud + 1)
   вказуватиме
   на другий елемент масиву (зміщення відносно вказівника stud на одну одиницю пам' яті), а вказівник (stud + 4)- на
   п'ятий
   (зміщення на чотири одиниці).<br>
   Проініціалізувати масив (надати значення елементам масиву) можна одним із способів:<br>
   • використовуючи принцип замовчування;<br>
   • безпосередньо під час його оголошення;<br>
   • застосовуючи команду присвоєння;<br>
   • під час введення даних із клавіатури.<br>
   За замовчуванням усім елементам масиву надається значення 0. Масив можна ініціалізувати повністю або частково відразу
   під час його
   оголошення, записуючи значення змінних через кому у фігурних дужках. Наприклад,
</p>
<p class="code">
   int Stud[] = {2, 1 0, 5, 7, З};<br>
   float rist[10] = {163.4, 154.6, 170, 172,8, };<br>
   char alphavit[6] = "Абетка"<br>
   або char alphavit[6] = {'А', 'б', 'е', 'т', 'к', 'а'}.<br>
</p>
<p class="regular text">
   Перші чотири елементи масиву rist були проініціалізовані, а решта- ні. Якщо масив повністю ініціалізують під час
   оголошення,
   то його розмір зазначати не обов'язково. У цьому випадку компілятор сам визначає, скільки пам'яті необхідно
   зарезервувати. У
   наведеному прикладі масив Stud складатиметься з п'яти цілих чисел .<br>
   Надати значення іншим елементам масиву rist або змінити значення вже проініціалізованих елементів можна командою
   присвоєння,
   наприклад, так: rist[З] = 175.4, rist[9] = 184.1 або так: *(rist + 2) = 164.5, *(rist + 7) = 148.0 тощо. Елементи
   масиву також
   можна вводити з клавіатури під час виконання програми, як це робимо для змінних простих стандартних типів.<br>
   Масиви-сталі (значення яких змінювати у програмі не можна) оголошують так: const int flag[] = {1, 2}.<br>
   Сталі масиви треба ініціалізувати під час оголошення, інакше елементам масиву автоматично будуть присвоєні нульові
   значення.
   Для опрацювання елементів масиву найчастіше використовують команду циклу for, хоча можна застосувати і whilebr або
   do-while.<br>
   <br>Приклад 1. Створити масив з перших ста цілих чисел і обчислити суму всіх його значень можна одним із
   способів:<br>
   1-й способів:<br>
</p>
<p class="code">
   int n[100]; <br>
   int S =0;<br>
   for (k = 0; k &lt 100; )<br>
   {<br>
   *(n+k) = ++k;<br>
   S += *(n+k);<br>
   }<br>
   <p class="regular">2-й спосіб: </p>
   <p class="code">
      int n[100]; // 2-й спосіб<br>
      int S =0;<br>
      for (k =0; k &lt 100; k++)<br>
      {<br>
      n[k] = k + 1;<br>
      S += n[k];<br>
      }<br>
   </p>
   <p class="regular">
      Задачі відшукання в масиві конкретних даних розв'язують методом сканування (перебирання, перегляду) всіх елементів
      масиву
      за допомогою циклу й умовної команди, де зазначають умову пошуку потрібних даних.
   </p>
   <p class="subTheme" id="subTheme4_1_2"> Динамічне оголошення масивів </p>
   <p class="regular">
      Під час компіляції програмного коду для статично оголошених масивів надається пам'ять. Для ефективного
      використання пам'яті
      призначене динамічне оголошення масивів, а саме:<br>
   </p>
   <p class="code">
      <тип вказівника> *<назва>= new <тип змінної>[<кількість>];
   </p>
   <p class="regular">
      Після виконання цієї команди буде виділена неперервна ділянка пам'яті обсягом sizeof(тиn змінної) * <кількість> ,
         і назва масиву
         вказуватиме на початок цієї ділянки. <br>
         3 динамічною змінною можна виконувати операції, визначені для даних відповідного базового типу.<br>
         Після опрацювання масиву вивільнити пам'ять можна за допомогою команди delete[] <назва вказівника на масив
            даних> ;<br>
            Під час вивільнення пам'яті розмір масиву зазначати не потрібно.<br>
            <br>Розв’яжемо задачу, з прикладу 1, використовуючи динамічний розподіл пам'яті
   </p>
   <p class="code">
      int *n = new int [100] ; // Виділяємо пам'ять для ста цілих чисел<br>
      for (int S = 0, k = 0; k &lt 100 ; )<br>
      { //Опрацьовуємо масив<br>
      *(n+k) = ++k;<br>
      S += *(n+k);<br>
      }<br>
      delete[] n; //Вивільняємо пам’ять <br>
   </p>
   <p class="regular text">
      3а допомогою динамічних змінних можна розв'язати задачу почергового опрацювання одною програмою деякої кількості
      великих масивів
      (якщо всі масиви не можливо одночасно ввести у пам ять). Задачу розв'язують так. Створюють масив, наприклад, *mas1
      = new [] і
      опрацьовують динамічні змінні *mas1, *(mas1+1), ... Вивільняють пам ять delete[] mas1. Створюють й опрацьовують
      елементи другого
      масиву *mas2 = new <тип> [<кількість>] і т.д.<br>
            <br>Задача 1 (про АТС). Нехай Yk - це число викликів, які надходять на АТС за k-ту секунду. Припустимо, що
            Yk - випадкове число зі
            значенням від 0 до 30. Утворити масив у з десятьма елементами (k = 1, 2, ... , 10). Обчислити суму викликів
            за перші 10 с роботи АТС.
            Визначити максимальну суму викликів, які надійшли за деяку одну секунду. Вивести результати обчислень.<br>
            <br>Увага! Для того, щоб отримати ціле випадкове число з діапазону від 0 до n, можна скористатись функцією
            random(n), яка описана
            у модулі stdlib.h. Щоб під час виконання програми кожен раз отримувати різні значення , перед використання
            функції random()
            треба записати функцію randomize().<br>
   </p>
   <p class="code">
      #include &lt iostream.h &gt<br>
      #include &lt conio.h &gt<br>
      #include &lt stdlib.h &gt<br>
      void main()<br>
      {<br>
      randomize();<br>
      clrscr();<br>
      int у[10];<br>
      cout &lt&lt "Секунда \t Кількість викликів \n";<br>
      for (int S =0, k =0; k &lt 10; k++)<br>
      {<br>
      y[k] = random(З0);<br>
      cout &lt&lt k+ 1 &lt&lt "\t\t" &lt&lt у[k] &lt&lt "\n";<br>
      S += *(у+ k); // або S += y[k];<br>
      }<br>
      cout &lt&lt "\n S=" &lt&lt S;<br>
      k =0;<br>
      for (int max =*у; k &lt 10; k++)<br>
      if (*(у+ k) > max)<br>
      max = *(у+ k);<br>
      cout &lt&lt "\n max = " &lt&lt max;<br>
      getch();<br>
      } <br>
   </p>
   <p class="subTheme" id="video7">Відео пояснення</p>
   <video controls>
      <source src="{% static 'video/7.mp4' %}" type="video/mp4">
   </video>
   <p class="subTheme" id="subTheme4_1_3"> Вказівники на функції</p>
   <p class="regular">
      На практиці виникають задачі однакового ' опрацювання масивів з різною кількістю елементів. Розглянемо, як просто
      у мові С++
      подібні задачі розв'язуються за допомогою вказівників.<br>
      У наведеній нижче програмі для визначення елементів масивів, що обчислюються за допомогою різних формул,
      використано тип даних-
      вказівник на функцію:<br>
   </p>
   <p class="code">
      <тип результату> (*<назва>) (<тип аргументу 1>, <тип аргументу 2>, ... , <тип аргументу n>)
   </p>
   <p class="regular">
      <br>Задача 2 (про масиви з різною кількістю елементів).<br>
      Утворити масив у, елементи якого задані формулою Ут= 10cosm + 2, m = 1, 2, ... , 7, та масив g з елементами gn =
      n^2 / 2,
      n = 1, 2, ... , 9. <br>
      Обчислити в цих масивах суми елементів більших, ніж 2. Вивести на екран результати обчислень.<br>
      // Масиви різної довжини
   </p>
   <p class="code">
      #include &lt iostream.h &lt<br>
      #include &lt conio.h &gt<br>
      #include &lt math.h &gt<br>
      #define Ny 7<br>
      #define Ng 9<br>
      float Fy(int m);<br>
      float Fg(int m);<br>
      void Utvoryty(float (*f)(int m), float *z, int n);<br>
      float Suma(float *z, int n);<br>
      void main()<br>
      {<br>
      float S;<br>
      float *у= new float[Ny] ;<br>
      cout &lt&lt "Масив Y:\n";<br>
      Utvoryty(Fy, у, Ny);<br>
      S = Suma(y, Ny);<br>
      cout &lt&lt "Сума елементів більших, ніж 2, у масиві У = " &lt&lt S;<br>
      delete[] y;<br>
      float *g = new float[Ng];<br>
      cout &lt&lt "\nМасив G:\n";<br>
      Utvoryty(Fg, g, Ng); S = Suma(g, Ng);<br>
      cout &lt&lt Сума елементів більших . ніж 2, у масиві G = " &lt&lt S;<br>
      delete[] g;<br>
      } <br>
      //-------------------------------------------------------------------- <br>
      float Fy(int m)<br>
      {<br>
      float f = 10 * cos(m) + 2 ;<br>
      return f;<br>
      } <br>
      //--------------------------------------------------------------------<br>
      float Fg(int m)<br>
      {<br>
      float f = m * m / 2;<br>
      return f;<br>
      } <br>
      //--------------------------------------------------------------------<br>
      void Utvoryty(float (*f)(int m), float , int n)<br>
      {<br>
      for (int і= 0; і &lt n; і++)<br>
      {<br>
      *(у + і) = f(i);<br>
      cout &lt&lt і &lt&lt "\t" &lt&lt у[і] &lt&lt "\n";<br>
      }<br>
      }<br>
      //--------------------------------------------------------------------<br>
      float Suma(float *z, int n)<br>
      {<br>
      float S;<br>
      for (int і =0; і &lt n; і++)<br>
      if (*(z + і) > 2) S += *(z + і);<br>
      return S ;<br>
      } <br>
   </p>
   {% endblock main %}

   {% block anchors %}
   <div class="anchors lessonWithVideo">
      <a href="#video7">Відео урок</a>
      <a href="#subTheme4_1_1">Масив це?</a>
      <a href="#subTheme4_1_2">Динамічне оголошення масивів</a>
      <a href="#subTheme4_1_3">Вказівники на функції</a>
   </div>
   {% endblock anchors %}